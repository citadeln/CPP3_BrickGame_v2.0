/**
 * @file
 * @brief Функции отрисовки интерфейса в окне консоли.
 */
#include "frontend.h"

using namespace s21;

/**
 * @brief Функция отрисовки актуального состояния игры.
 *
 * Функция выводит игровое поле, следующую фигуру, статистику,
 * и дополнительные сообщения (старт, пауза, gameover, выход).
 *
 * @param GameInfo_t Структура с актуальными данными для вывода.
 */
void print_game(GameInfo_t gameinfo) {
  // вывод поля
  for (int y = Y_START + 2; y < Y_FIELD + 2; y++) {
    int shift = 0;
    for (int x = X_START; x < X_FIELD; x++) {
      if (gameinfo.field[y][x]) {
        attron(COLOR_PAIR(gameinfo.field[y][x]));
        mvaddstr(y - 1, x + 1 + shift, "[]");
        attroff(COLOR_PAIR(gameinfo.field[y][x]));
      } else {
        mvaddstr(y - 1, x + 1 + shift, "  ");
      }
      shift++;
    }
  }

  // вывод следующей фигуры
  for (int y = 1; y < MAX_FIGURE_SIZE - 1; y++) {
    int shift = 0;
    for (int x = 0; x < MAX_FIGURE_SIZE; x++) {
      if (gameinfo.next[y][x]) {
        attron(COLOR_PAIR(gameinfo.next[y][x]));
        mvaddstr(y + 13, x + X_FIELD * 2 + HUD_WIDTH / 2 - 1 + shift, "[]");
        attroff(COLOR_PAIR(gameinfo.next[y][x]));
      } else
        mvaddstr(y + 13, x + X_FIELD * 2 + HUD_WIDTH / 2 - 1 + shift, "  ");
      shift++;
    }
  }

  // вывод статистики
  print_stats(gameinfo);

  // вывод доп сообщений
  if (gameinfo.pause == 1) {
    print_pause();
  } else if (gameinfo.pause == 2) {
    print_overlay();
    print_start();
  } else if (gameinfo.pause == 3) {
    print_gameover();
  } else if (gameinfo.pause == -1)
    print_exit();

  refresh();
}

/**
 * @brief Функция отрисовки границ игрового поля и заголовков.
 *
 * Функция выводит границы игрового поля, границы полей статистики и заголовков.
 */
void print_overlay() {
  print_rectangle(0, Y_FIELD + 1, 0, X_FIELD * 2 + 1);
  print_rectangle(0, Y_FIELD + 1, X_FIELD * 2 + 2, X_FIELD * 2 + HUD_WIDTH + 3);

  print_rectangle(1, 3, X_FIELD * 2 + 3, X_FIELD * 2 + HUD_WIDTH + 2);
  mvprintw(1, X_FIELD * 2 + HUD_WIDTH / 2, "HiSCORE");
  print_rectangle(4, 6, X_FIELD * 2 + 3, X_FIELD * 2 + HUD_WIDTH + 2);
  mvprintw(4, X_FIELD * 2 + HUD_WIDTH / 2 + 1, "SCORE");
  print_rectangle(7, 9, X_FIELD * 2 + 3, X_FIELD * 2 + HUD_WIDTH + 2);
  mvprintw(7, X_FIELD * 2 + HUD_WIDTH / 2 + 1, "LEVEL");
  print_rectangle(10, 12, X_FIELD * 2 + 3, X_FIELD * 2 + HUD_WIDTH + 2);
  mvprintw(10, X_FIELD * 2 + HUD_WIDTH / 2 + 1, "SPEED");
  print_rectangle(13, 16, X_FIELD * 2 + 3, X_FIELD * 2 + HUD_WIDTH + 2);
  mvprintw(13, X_FIELD * 2 + HUD_WIDTH / 2 + 1, "NEXT");
  mvprintw(18, X_FIELD * 2 + HUD_WIDTH / 2 - 1, "p - pause");
  mvprintw(19, X_FIELD * 2 + HUD_WIDTH / 2 - 1, "q - exit");
}

/**
 * @brief Функция отрисовки стартового сообщения.
 *
 * Функция выводит стартовое приветствие.
 */
void print_start() {
  // print_rectangle(Y_FIELD / 2 - 1, Y_FIELD / 2 + 2, X_FIELD - 5, X_FIELD +
  // 7);
  mvprintw(Y_FIELD / 2, X_FIELD - 4, "Press ENTER");
  mvprintw(Y_FIELD / 2 + 1, X_FIELD - 4, " to start! ");
}

/**
 * @brief Функция отрисовки сообщения паузы.
 *
 * Функция выводит сообщение о паузе в игре.
 */
void print_pause() {
  print_rectangle(Y_FIELD / 2 - 1, Y_FIELD / 2 + 1, X_FIELD - 4, X_FIELD + 4);
  mvprintw(Y_FIELD / 2, X_FIELD - 3, " PAUSE ");
}

/**
 * @brief Функция отрисовки сообщения gameover.
 *
 * Функция выводит сообщение о конце игры.
 */
void print_gameover() {
  print_rectangle(Y_FIELD / 2 - 1, Y_FIELD / 2 + 2, X_FIELD - 7, X_FIELD + 7);
  mvprintw(Y_FIELD / 2, X_FIELD - 6, "  GAME OVER  ");
  mvprintw(Y_FIELD / 2 + 1, X_FIELD - 6, "Press any key");
  refresh();
  nodelay(stdscr, FALSE);
  getch();
  nodelay(stdscr, TRUE);
}

/**
 * @brief Функция отрисовки сообщения выхода.
 *
 * Функция выводит сообщение о выходе из программы.
 */
void print_exit() {
  mvaddch(Y_FIELD / 2 - 1, 0, ACS_LTEE);
  mvaddch(Y_FIELD / 2 - 1, X_FIELD * 2 + 1, ACS_RTEE);
  mvhline(Y_FIELD / 2 - 1, 1, ACS_HLINE, X_FIELD * 2);
  mvprintw(Y_FIELD / 2, X_FIELD - 9, " THANKS FOR PLAYING ");
  mvprintw(Y_FIELD / 2 + 1, X_FIELD - 9, "   Press any key    ");
  mvaddch(Y_FIELD / 2 + 2, 0, ACS_LTEE);
  mvaddch(Y_FIELD / 2 + 2, X_FIELD * 2 + 1, ACS_RTEE);
  mvhline(Y_FIELD / 2 + 2, 1, ACS_HLINE, X_FIELD * 2);
  refresh();
  nodelay(stdscr, FALSE);
  getch();
  nodelay(stdscr, TRUE);
}

/**
 * @brief Функция отрисовки статистики.
 *
 * Функция выводит актуальную статистику по игре:
 *  - рекорд
 *  - текущий счет
 *  - текущий уровень
 *  - текущую скорость падения фигуры в микросекундах
 *
 * @param gameinfo Структура с актаульными данными статистики игры.
 */
void print_stats(GameInfo_t gameinfo) {
  if (gameinfo.high_score > gameinfo.score)
    mvprintw(2, X_FIELD * 2 + HUD_WIDTH / 2 + 1, "%04d", gameinfo.high_score);
  else
    mvprintw(2, X_FIELD * 2 + HUD_WIDTH / 2 + 1, "%04d", gameinfo.score);

  mvprintw(5, X_FIELD * 2 + HUD_WIDTH / 2 + 1, "%04d", gameinfo.score);
  mvprintw(8, X_FIELD * 2 + HUD_WIDTH / 2 + 3, "%d ", gameinfo.level);
  mvprintw(11, X_FIELD * 2 + HUD_WIDTH / 2 + 1, "0.%d",
           gameinfo.speed / 10000000);
}

/**
 * @brief Функция отрисовки прямоугольника.
 *
 * Функция отрисовки прямоугольника.
 *
 * @param y1 Координата левого верхнего угла по оси Y
 * @param y2 Координата правого нижнего угла по оси Y
 * @param x1 Координата левого верхнего угла по оси X
 * @param x2 Координата правого нижнего угла по оси X
 */
void print_rectangle(int y1, int y2, int x1, int x2) {
  // горизонтальные линии
  mvhline(y1, x1, ACS_HLINE, x2 - x1);
  mvhline(y2, x1, ACS_HLINE, x2 - x1);

  // вертикальные линии
  mvvline(y1, x1, ACS_VLINE, y2 - y1);
  mvvline(y1, x2, ACS_VLINE, y2 - y1);

  // углы
  mvaddch(y1, x1, ACS_ULCORNER);
  mvaddch(y2, x1, ACS_LLCORNER);
  mvaddch(y1, x2, ACS_URCORNER);
  mvaddch(y2, x2, ACS_LRCORNER);
}